#!/usr/bin/env bash

# For configuration, use the INIFILE
INIFILE=.pre-commitrc

# Search in the git root for the INIFILE
FULLPATH=$(git rev-parse --show-toplevel 2>/dev/null)
if [[ -n "${FULLPATH}" ]]; then
    INIFILE="${FULLPATH}/${INIFILE}"
    # Ensure that this hook can be executed from anywhere in the git repository
     pushd "${FULLPATH}" 2>/dev/null
fi

# Read INI file if it exists
[[ -f "${INIFILE}" ]] && source <(grep = "${INIFILE}")

# The following parameters are supported:
# DISABLE_CHECK_ON_MASTER=TRUE  # Allow commits to master branch

# exit as soon as a test fails
set -e

if git rev-parse --verify HEAD >/dev/null 2>&1; then
    branch="$(git rev-parse --abbrev-ref HEAD)"
    against=HEAD
    tag="$(git tag --contains)"
else
    # Initial commit: diff against an empty tree object
    against=$(git hash-object -t tree /dev/null)
fi

# Redirect output to stderr.
exec 1>&2

check_branch() {
    # Check whether this is the master branch
    if [[ "${branch}" = "master" ]] && [[ -z "${DISABLE_CHECK_ON_MASTER}" ]]; then
        # Check whether this commit does not contain a tag
        if [[ -z "${tag}" ]]; then
            # Check whether the file isn't only CHANGELOG.md
            if [ "$(git diff --cached --name-only|xargs)" != "CHANGELOG.md" ]; then
               echo "Committing directly to master branch is not allowed, except for tags,"
               echo "or only the file CHANGELOG.md."
               echo "Bypass the pre-commit hook using the --no-verify parameter, or"
               echo "add the following string to the configuration file using:"
               echo "echo DISABLE_CHECK_ON_MASTER=TRUE >> ${INIFILE}"
               exit 1
            fi
        fi
    fi
}

do_prettier() {
    if which prettier &>/dev/null; then
        echo "Performing style check of $1"
        prettier --check "$1"
    fi
}

validate_jenkinsfile() {
    if [[ $1 =~ ^Jenkinsfile$ ]]; then
        if which lint-jenkins &>/dev/null; then
            echo "Validating Jenkins Groovy file $1"
            lint-jenkins "$1"
        fi
    fi
}

validate_jinja() {
    if [[ "$1" =~ \.(j2|yaml|yml)$ ]]; then
        if which lint-jinja &>/dev/null; then
            echo "Validating Jinja file $1"
            lint-jinja "$1"
        fi
    fi
}

validate_python() {
    if [[ "$1" =~ \.py$ ]]; then
        if which pylint 2>/dev/null; then
            echo "Validating Python file $1"
            pylint "$1" || pylint-exit --error-fail $?
        fi
    fi
}

validate_rst() {
    if [[ "$1" =~ \.(rest|rst)$ ]]; then
        if which rst-lint &>/dev/null; then
            echo "Validating reStructuredText file $1"
            rst-lint "$1"
        fi
    fi
}

validate_shell() {
    if [[ "$1" =~ \.(bash|.sh)$ ]]; then
        if which shellcheck &>/dev/null; then
            echo "Validating shell script file $1"
            shellcheck "$1"
        fi
    fi
}

validate_xml() {
    if [[ "$1" =~ \.xml$ ]]; then
        if which xmllint &>/dev/null; then
            echo "Validating XML file $1"
            xmllint --valid "$1"
        fi
    fi
}

validate_yaml() {
    if [[ "$1" =~ \.(yaml|yml)$ ]]; then
        if which yamllint &>/dev/null; then
            echo "Validating YAML file $1"
            yamllint --strict "$1"
        fi
    fi
}

validate_files() {
    for file in $(git diff --cached --name-only "${against}"); do
        do_prettier "$file"
        validate_jenkinsfile "$file"
        validate_jinja "$file"
        validate_python "$file"
        validate_rst "$file"
        validate_shell "$file"
        validate_xml "$file"
        validate_yaml "$file"
    done
}

check_branch
validate_files
popd 1>/dev/null
